# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI Fast - No Docker (Phase 1: Lightweight PR Checks)
# Purpose: Run on every push/PR for fast feedback without Docker
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: CI Fast (No Docker)

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 0: Secret Scanning (Security First)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  secret-scan:
    name: 'Secret Scanning'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Gitleaks Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE || 'free' }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 1: S1 Compliance Validation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  s1-compliance:
    name: 'S1 Protocol Compliance Check'
    runs-on: ubuntu-latest
    needs: secret-scan
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.0.0'

      - name: Check S1 Environment File Exists
        run: |
          if [ ! -f "apps/api/.env.s1.local" ]; then
            echo "âŒ S1 Environment file not found (apps/api/.env.s1.local)"
            exit 1
          fi
          echo "âœ… S1 Environment file exists"

      - name: Validate S1 Variables
        run: |
          echo "ğŸ” Checking S1 Required Variables..."
          required_vars=("DATABASE_URL" "REDIS_URL" "S3_ENDPOINT" "TENANT_ISOLATION_MODE")
          for var in "${required_vars[@]}"; do
            if ! grep -q "^${var}=" apps/api/.env.s1.local; then
              echo "âŒ Missing required S1 variable: ${var}"
              exit 1
            fi
          done
          echo "âœ… All S1 required variables present"

      - name: Verify S1 Isolation Mode
        run: |
          isolation_mode=$(grep "^TENANT_ISOLATION_MODE=" apps/api/.env.s1.local | cut -d= -f2 | tr -d '"')
          if [ "$isolation_mode" != "strict" ]; then
            echo "âŒ TENANT_ISOLATION_MODE must be 'strict' for S1 compliance (found: ${isolation_mode})"
            exit 1
          fi
          echo "âœ… S1 Strict Isolation Mode verified"

      - name: Check S1 Schema Prefix
        run: |
          echo "ğŸ” Checking for unauthorized public. schema references..."
          # Debug: show all matches first
          echo "All matches:"
          grep -rn "public\." packages/db/src --include="*.ts" --exclude="*.test.ts" --exclude="*.spec.ts" || true
          
          # Look for actual schema references like "public.table_name" 
          # Exclude: audit_logs (S4 exception), comments, search_path uses
          violations=$(grep -rn "public\." packages/db/src --include="*.ts" --exclude="*.test.ts" --exclude="*.spec.ts" | \
            grep -v "audit_logs" | \
            grep -v "node_modules" | \
            grep -v "//.*public\." | \
            grep -v "search_path.*public" | \
            grep -v "getTenantTableName" | \
            grep -v "tenant_" | \
            head -5)
          if [ -n "$violations" ]; then
            echo "âŒ S1 Violation: Found unauthorized 'public.' schema references:"
            echo "$violations"
            exit 1
          fi
          echo "âœ… No unauthorized public. schema references"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 2: Security Audit
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  security-audit:
    name: 'Security Audit & Lint'
    runs-on: ubuntu-latest
    needs: secret-scan
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.0.0'

      - name: Install Dependencies
        run: bun install

      - name: Biome Lint Check
        run: bun run lint || echo "âš ï¸ Biome lint issues (non-blocking for Phase 1)"

      - name: Type Check (TSC)
        run: |
          echo "ğŸ“ Running TypeScript type checking..."
          bunx tsc --noEmit || echo "âš ï¸ Type errors detected (non-blocking for Phase 1)"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 3: Database Schema Validation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  db-schema:
    name: 'Database Schema Validation'
    runs-on: ubuntu-latest
    needs: s1-compliance
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.0.0'

      - name: Install Dependencies
        run: bun install

      - name: Check Drizzle Schema Files
        run: |
          if [ ! -f "packages/db/src/schema.ts" ]; then
            echo "âŒ Drizzle schema file not found"
            exit 1
          fi
          echo "âœ… Drizzle schema file exists"

      - name: Schema Validation
        run: |
          cd packages/db
          echo "ğŸ” Validating schema structure..."
          # Check for tenant_id columns in tables
          tenant_tables=$(grep -c "tenantId" src/schema.ts || echo "0")
          echo "Found ${tenant_tables} references to tenant isolation"
          if [ "$tenant_tables" -eq 0 ]; then
            echo "âŒ No tenant isolation columns found in schema"
            exit 1
          fi
          echo "âœ… Tenant isolation schema verified"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 4: Dependency Boundary Check
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  boundary-check:
    name: 'Dependency Boundary Check (Rule 1.1)'
    runs-on: ubuntu-latest
    needs: [s1-compliance]
    steps:
      - uses: actions/checkout@v4
      - name: Check Cross-Boundary Imports
        run: |
          echo "ğŸ” Checking for cross-boundary imports..."
          
          # Check that web doesn't import from api
          web_api_imports=$(grep -r "from.*apps/api" apps/web --include="*.ts" --include="*.tsx" 2>/dev/null | wc -l)
          
          # Check that packages don't import from apps
          pkg_app_imports=$(grep -r "from.*apps/" packages/ --include="*.ts" 2>/dev/null | wc -l)
          
          if [ "$web_api_imports" -gt 0 ]; then
            echo "âŒ Rule 1.1 Violation: apps/web imports from apps/api"
            grep -r "from.*apps/api" apps/web --include="*.ts" --include="*.tsx" 2>/dev/null || true
            exit 1
          fi
          
          if [ "$pkg_app_imports" -gt 0 ]; then
            echo "âŒ Rule 1.1 Violation: packages/ import from apps/"
            grep -r "from.*apps/" packages/ --include="*.ts" 2>/dev/null || true
            exit 1
          fi
          
          echo "âœ… No cross-boundary import violations"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 5: Zod Schema Lockdown Check
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  zod-check:
    name: 'Zod Schema Lockdown (Rule 5.1)'
    runs-on: ubuntu-latest
    needs: [db-schema]
    steps:
      - uses: actions/checkout@v4
      - name: Verify Zod Usage
        run: |
          echo "ğŸ” Checking Zod Schema Compliance..."
          
          # Count Zod schema definitions
          zod_count=$(find packages apps -name "*.ts" -exec grep -l "z\." {} \; 2>/dev/null | wc -l)
          echo "Found ${zod_count} files using Zod"
          
          # Check for any raw type assertions that bypass Zod
          bypass_patterns=("as any" "as unknown" "@ts-ignore" "@ts-expect-error")
          bypass_count=0
          for pattern in "${bypass_patterns[@]}"; do
            count=$(grep -r "$pattern" packages/*/src apps/*/src --include="*.ts" 2>/dev/null | grep -v "node_modules" | wc -l)
            bypass_count=$((bypass_count + count))
          done
          
          if [ "$bypass_count" -gt 0 ]; then
            echo "âš ï¸ Warning: Found ${bypass_count} potential type bypass patterns"
            echo "These should be reviewed for Rule 5.1 compliance"
          fi
          
          echo "âœ… Zod schema check complete"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 6: Build
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build:
    name: 'Turborepo Build'
    runs-on: ubuntu-latest
    needs: [security-audit, boundary-check, zod-check]
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.0.0'

      - name: Install Dependencies
        run: bun install

      - name: Verify turbo.json
        run: |
          if [ ! -f "turbo.json" ]; then
            echo "âŒ turbo.json not found"
            exit 1
          fi
          
          # Check for correct tasks structure (Turbo v2+)
          if grep -q '"pipeline"' turbo.json; then
            echo "âš ï¸ Warning: turbo.json uses deprecated 'pipeline' key, should be 'tasks'"
          fi
          echo "âœ… turbo.json exists"

      - name: Build Packages
        run: |
          echo "ğŸ—ï¸ Building packages..."
          bun run build
        env:
          NODE_ENV: production

      - name: Verify Build Artifacts
        run: |
          echo "ğŸ” Verifying build artifacts..."
          for pkg in packages/*/; do
            if [ -f "${pkg}src/index.ts" ]; then
              if [ ! -d "${pkg}dist" ]; then
                echo "âš ï¸ Warning: ${pkg} missing dist folder"
              else
                echo "âœ… ${pkg} build artifacts exist"
              fi
            fi
          done

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            packages/*/dist/**
            apps/api/dist/**
            apps/web/.next/**
          retention-days: 1

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 7: Unit Tests (No Docker)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  unit-tests:
    name: 'Unit Tests (No Docker)'
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.0.0'

      - name: Install Dependencies
        run: bun install

      - name: Run Unit Tests
        run: |
          echo "ğŸ§ª Running unit tests..."
          # turbo doesn't support --coverage flag, run vitest directly
          bunx vitest run --coverage --reporter=verbose
        env:
          NODE_ENV: test
          SKIP_DOCKER_TESTS: true

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report-unit
          path: |
            coverage/**
            packages/*/coverage/**
          retention-days: 7

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 8: Coverage Gate (Production: 90% threshold)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  coverage-gate:
    name: 'Coverage Gate (90% Production)'
    runs-on: ubuntu-latest
    needs: unit-tests
    if: always() && needs.unit-tests.result == 'success'
    steps:
      - uses: actions/checkout@v4
      - name: Download Coverage Reports
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: coverage-report-unit
          path: coverage/

      - name: Check Coverage Threshold
        run: |
          echo "ğŸ” Checking Coverage Threshold (Production: 90%)..."
          
          if [ -f "coverage/coverage-summary.json" ]; then
            overall=$(cat coverage/coverage-summary.json | grep -o '"lines":{"total":[0-9]*,"covered":[0-9]*,"skipped":[0-9]*,"pct":[0-9.]*' | grep -o '"pct":[0-9.]*' | head -1 | cut -d: -f2)
            echo "Overall Line Coverage: ${overall}%"
            
            # Production requirement: 90% coverage
            if (( $(echo "$overall < 90" | bc -l 2>/dev/null || echo "0") )); then
              echo "âŒ FAIL: Coverage ${overall}% below 90% production threshold"
              echo "ğŸ“Š Required: 90% | Actual: ${overall}%"
              echo "ğŸ’¡ Tip: Add tests for uncovered lines before merging"
              exit 1
            fi
            echo "âœ… Coverage ${overall}% meets production threshold (90%)"
          else
            echo "âŒ FAIL: No coverage summary found"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 8b: API Performance Tests (Response Time < 50ms)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  performance-tests:
    name: 'API Performance Tests (< 50ms)'
    runs-on: ubuntu-latest
    needs: [docker-check]
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install Dependencies
        run: bun install

      - name: Start API Server
        run: |
          echo "ğŸš€ Starting API server for performance tests..."
          cd apps/api
          bun run src/main.ts &
          echo $! > /tmp/api.pid
          
          # Wait for server
          for i in {1..30}; do
            if curl -s http://localhost:3000/ > /dev/null 2>&1; then
              echo "âœ… API server is ready"
              break
            fi
            sleep 1
          done
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret-performance-test
          NODE_ENV: test
          PORT: 3000

      - name: Run Performance Tests
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  API Performance Tests (Target: < 50ms p95)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          API_URL="http://localhost:3000"
          
          # Function to measure response time
          measure_endpoint() {
            local endpoint=$1
            local method=${2:-GET}
            local body=$3
            
            # Run 10 requests and calculate average
            total_time=0
            max_time=0
            
            for i in {1..10}; do
              if [ "$method" = "POST" ]; then
                time_ms=$(curl -s -o /dev/null -w "%{time_total}" \
                  -X POST "$API_URL$endpoint" \
                  -H "Content-Type: application/json" \
                  -d "$body" 2>/dev/null || echo "0")
              else
                time_ms=$(curl -s -o /dev/null -w "%{time_total}" \
                  "$API_URL$endpoint" 2>/dev/null || echo "0")
              fi
              
              # Convert to milliseconds (curl returns seconds)
              time_ms=$(echo "$time_ms * 1000" | bc)
              time_ms=${time_ms%.*}
              
              total_time=$((total_time + time_ms))
              
              if [ $time_ms -gt $max_time ]; then
                max_time=$time_ms
              fi
            done
            
            avg_time=$((total_time / 10))
            echo "$avg_time $max_time"
          }
          
          # Test endpoints
          echo "Testing API endpoints..."
          
          # Health/Root endpoint
          read avg max < <(measure_endpoint "/")
          echo "GET /: avg=${avg}ms max=${max}ms"
          
          if [ $avg -gt 50 ]; then
            echo "âŒ FAIL: GET / average response time (${avg}ms) exceeds 50ms threshold"
            exit 1
          fi
          
          # Provision endpoint (POST)
          read avg max < <(measure_endpoint "/api/provision" "POST" '{}')
          echo "POST /api/provision: avg=${avg}ms max=${max}ms"
          
          # For write operations, we allow slightly more but still check
          if [ $avg -gt 100 ]; then
            echo "âš ï¸ WARNING: POST /api/provision average (${avg}ms) is high (target: < 100ms)"
          fi
          
          echo ""
          echo "âœ… All performance tests passed"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Stop API Server
        if: always()
        run: |
          if [ -f /tmp/api.pid ]; then
            kill $(cat /tmp/api.pid) 2>/dev/null || true
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 9: Docker Validation (Build & Health Check)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  docker-check:
    name: 'Docker & Docker Compose Validation'
    runs-on: ubuntu-latest
    needs: [build]
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Check Docker Files Exist
        run: |
          echo "ğŸ” Checking Docker files..."
          
          if [ ! -f "Dockerfile" ]; then
            echo "âš ï¸ Warning: Dockerfile not found in root"
          else
            echo "âœ… Dockerfile exists"
          fi
          
          if [ ! -f "docker-compose.yml" ]; then
            echo "âŒ docker-compose.yml not found"
            exit 1
          fi
          echo "âœ… docker-compose.yml exists"
      
      - name: Validate docker-compose.yml Syntax
        run: |
          echo "ğŸ” Validating docker-compose.yml syntax..."
          docker compose config > /dev/null
          echo "âœ… docker-compose.yml syntax is valid"
      
      - name: Validate Dockerfile Syntax
        run: |
          if [ -f "Dockerfile" ]; then
            echo "ğŸ” Validating Dockerfile..."
            # Check for common Dockerfile issues
            if grep -q "^FROM" Dockerfile; then
              echo "âœ… Dockerfile has FROM instruction"
            else
              echo "âŒ Dockerfile missing FROM instruction"
              exit 1
            fi
            
            if grep -q "latest" Dockerfile; then
              echo "âš ï¸ Warning: Dockerfile uses 'latest' tag (not recommended for production)"
            fi
            
            echo "âœ… Dockerfile validation complete"
          fi
      
      - name: Wait for Services Health
        run: |
          echo "â³ Waiting for services to be healthy..."
          sleep 10
          echo "âœ… Services should be ready"
      
      - name: Check Service Ports
        run: |
          echo "ğŸ” Checking exposed ports..."
          
          # Install netcat if not present
          which nc || sudo apt-get install -y netcat-openbsd
          
          # Check if services are accessible
          if nc -z localhost 5432; then
            echo "âœ… PostgreSQL port (5432) is accessible"
          else
            echo "âŒ PostgreSQL port (5432) is not accessible"
            exit 1
          fi
          
          if nc -z localhost 6379; then
            echo "âœ… Redis port (6379) is accessible"
          else
            echo "âŒ Redis port (6379) is not accessible"
            exit 1
          fi
          
          echo "âœ… All service ports are accessible"
      
      - name: Test Database Connectivity
        run: |
          echo "ğŸ” Testing database connectivity..."
          
          # Test PostgreSQL
          if command -v psql &> /dev/null; then
            PGPASSWORD=test psql -h localhost -U test -d test -c "SELECT 1;" > /dev/null 2>&1 && echo "âœ… PostgreSQL connection successful" || echo "âš ï¸ PostgreSQL connection test skipped"
          else
            echo "âš ï¸ psql not available, skipping connection test"
          fi
          
          # Test Redis
          if command -v redis-cli &> /dev/null; then
            redis-cli -h localhost ping | grep -q "PONG" && echo "âœ… Redis connection successful" || echo "âš ï¸ Redis connection test skipped"
          else
            echo "âš ï¸ redis-cli not available, skipping connection test"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Phase 10: Final Summary
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: 'CI Summary'
    runs-on: ubuntu-latest
    needs: [secret-scan, s1-compliance, security-audit, build, unit-tests, coverage-gate, performance-tests, docker-check]
    if: always()
    steps:
      - name: Report Status
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "                    CI Fast Summary"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Security:"
          echo "  Secret Scan:     ${{ needs.secret-scan.result }}"
          echo "  S1 Compliance:   ${{ needs.s1-compliance.result }}"
          echo "  Security Audit:  ${{ needs.security-audit.result }}"
          echo ""
          echo "Build & Test:"
          echo "  Build:           ${{ needs.build.result }}"
          echo "  Unit Tests:      ${{ needs.unit-tests.result }}"
          echo "  Coverage Gate:   ${{ needs.coverage-gate.result }} (90% required)"
          echo "  Performance:     ${{ needs.performance-tests.result }} (< 50ms)"
          echo ""
          echo "Infrastructure:"
          echo "  Docker Check:    ${{ needs.docker-check.result }}"
          echo ""
          
          # All critical gates must pass
          if [ "${{ needs.build.result }}" == "success" ] && \
             [ "${{ needs.unit-tests.result }}" == "success" ] && \
             [ "${{ needs.coverage-gate.result }}" == "success" ] && \
             [ "${{ needs.performance-tests.result }}" == "success" ]; then
            echo "âœ… CI Fast PASSED - All gates cleared"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          else
            echo "âŒ CI Fast FAILED - Check failed gates above"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            exit 1
          fi
