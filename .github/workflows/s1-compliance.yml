name: S1-S8 Security Compliance CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

permissions:
  contents: read
  security-events: write

env:
  JWT_SECRET: test_secret_key_for_ci_environment_only_32
  DATABASE_URL: postgresql://test:test@localhost:5432/test
  MINIO_ACCESS_KEY: test
  MINIO_SECRET_KEY: minioadmin123
  MINIO_ENDPOINT: localhost

jobs:
  secret-scan:
    name: Secret Scanning (Gitleaks)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  s1-compliance:
    name: S1 Environment Verification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Test S1 Crash on Invalid JWT_SECRET
        run: |
          # Test 1: Missing JWT_SECRET should crash
          if JWT_SECRET="" bun run packages/config/src/index.ts 2>&1; then
            echo "‚ùå FAIL: App should have crashed with empty JWT_SECRET"
            exit 1
          else
            echo "‚úÖ PASS: App crashed as expected with empty JWT_SECRET"
          fi

          # Test 2: Short JWT_SECRET should crash
          if JWT_SECRET="short" bun run packages/config/src/index.ts 2>&1; then
            echo "‚ùå FAIL: App should have crashed with short JWT_SECRET"
            exit 1
          else
            echo "‚úÖ PASS: App crashed as expected with short JWT_SECRET"
          fi

          # Test 3: Valid JWT_SECRET should pass
          if bun run packages/config/src/index.ts 2>&1; then
            echo "‚úÖ PASS: App started with valid JWT_SECRET"
          else
            echo "‚ùå FAIL: App should have started with valid JWT_SECRET"
            exit 1
          fi

  security-audit-lint:
    name: Security Audit & Linting (Strict)
    runs-on: ubuntu-latest
    needs: [secret-scan]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Security Audit (S1 - Critical/High)
        run: bun audit

      - name: TypeScript Check (Strict Mode)
        run: bun x tsc --noEmit --strict

      - name: Biome CI (Strict)
        run: bun run biome ci .

      - name: Verify no console.log (S4 Compliance)
        run: |
          # Exclude test files and comments from the check
          if grep -r "console.log" packages/*/src/*.ts --include="*.ts" | \
             grep -v "\.test\.ts:" | \
             grep -v "console.warn" | \
             grep -v "console.error" | \
             grep -v "// " | \
             grep -v "/\*"; then
            echo "‚ùå FAIL: console.log found. Use structured logging instead (S4)."
            exit 1
          fi

  dependency-boundary-check:
    name: Dependency Boundary Check (Rule 1.1)
    runs-on: ubuntu-latest
    needs: [security-audit-lint]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Verify No Cross-App Imports (Rule 1.1)
        run: |
          echo "üîç Checking for Cross-App Imports (Rule 1.1)..."
          
          # Check each app doesn't import from other apps
          APPS=("apps/api" "apps/storefront" "apps/admin")
          
          for app in "${APPS[@]}"; do
            app_name=$(basename "$app")
            echo "Checking $app_name..."
            
            # Find all imports from apps/* in this app
            cross_imports=$(grep -r "from ['\"]apps/" "$app/src" --include="*.ts" 2>/dev/null || true)
            
            if [ -n "$cross_imports" ]; then
              echo "‚ùå FAIL: Cross-App imports found in $app_name:"
              echo "$cross_imports"
              exit 1
            fi
            
            # Check for relative imports to other apps
            illegal_imports=$(grep -r "from ['\"]\.\./\./" "$app/src" --include="*.ts" | grep -E "(apps|storefront|admin|api)" || true)
            
            if [ -n "$illegal_imports" ]; then
              echo "‚ùå FAIL: Illegal relative imports found in $app_name:"
              echo "$illegal_imports"
              exit 1
            fi
          done
          
          echo "‚úÖ PASS: No Cross-App imports found (Rule 1.1 Compliant)"

      - name: Verify Packages Import Only (Rule 1.1 Extension)
        run: |
          echo "üîç Verifying apps only import from packages/*..."
          
          # Check apps only import from packages/* or external dependencies
          illegal_imports=$(grep -r "from ['\"]\.\." apps/*/src --include="*.ts" | grep -v "packages/" | grep -v "node_modules" || true)
          
          if [ -n "$illegal_imports" ]; then
            echo "‚ùå FAIL: Apps should only import from packages/* or external deps:"
            echo "$illegal_imports"
            exit 1
          fi
          
          echo "‚úÖ PASS: Apps only import from packages/* (Clean Architecture)"

  violation-detection-cross-app:
    name: üö® Violation Detection - Cross-App Import (Rule 1.1)
    runs-on: ubuntu-latest
    needs: [dependency-boundary-check]
    if: failure()
    steps:
      - name: Report Cross-App Import Violation
        run: |
          echo "üö® CRITICAL VIOLATION DETECTED: Rule 1.1 (App Isolation)"
          echo ""
          echo "‚ùå A cross-app import was detected!"
          echo ""
          echo "üìã Violation Details:"
          echo "   - Rule: No app in apps/* can import from another app"
          echo "   - Solution: Move shared code to packages/*"
          echo ""
          echo "üõë Build rejected. Fix the import before merging."
          exit 1

  biome-ignore-detection:
    name: üö® Violation Detection - Biome Ignore Comments
    runs-on: ubuntu-latest
    needs: [security-audit-lint]
    steps:
      - uses: actions/checkout@v4

      - name: Detect // biome-ignore Comments
        run: |
          echo "üîç Scanning for // biome-ignore comments (Rule: No Bypassing Lint)..."
          
          # Find all // biome-ignore comments in source files (excluding tests)
          ignore_comments=$(grep -r "// biome-ignore" packages/*/src apps/*/src --include="*.ts" --include="*.tsx" | grep -v "\.test\." | grep -v "\.spec\." || true)
          
          if [ -n "$ignore_comments" ]; then
            echo "üö® VIOLATION DETECTED: // biome-ignore comments found!"
            echo ""
            echo "‚ùå The following files contain lint bypass comments:"
            echo "$ignore_comments"
            echo ""
            echo "üìã Why this is dangerous:"
            echo "   - biome-ignore disables code quality checks"
            echo "   - May hide security vulnerabilities"
            echo "   - Violates project coding standards"
            echo ""
            echo "üìù Action Required:"
            echo "   1. Remove the // biome-ignore comment"
            echo "   2. Fix the underlying issue properly"
            echo "   3. If absolutely necessary, get architect approval"
            exit 1
          fi
          
          echo "‚úÖ PASS: No // biome-ignore comments found in source code"

      - name: Detect eslint-disable Comments
        run: |
          echo "üîç Scanning for eslint-disable comments..."
          
          # Find eslint-disable comments (excluding console.error/warn)
          eslint_disables=$(grep -r "eslint-disable" packages/*/src apps/*/src --include="*.ts" --include="*.tsx" | grep -v "eslint-disable-next-line no-console" | grep -v "\.test\." || true)
          
          if [ -n "$eslint_disables" ]; then
            echo "‚ö†Ô∏è WARNING: eslint-disable comments found:"
            echo "$eslint_disables"
            echo ""
            echo "Review these to ensure they're justified."
            # Don't fail, just warn
          else
            echo "‚úÖ PASS: No eslint-disable comments found"
          fi

  s1-fail-fast-test:
    name: üö® Violation Detection - S1 Fail-Fast Protocol
    runs-on: ubuntu-latest
    needs: [s1-compliance]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: apex
          POSTGRES_PASSWORD: apex
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Test S1 Fail-Fast - Invalid JWT_SECRET
        run: |
          echo "üß™ Testing S1 Fail-Fast Protocol..."
          echo ""
          
          # Test 1: App must crash with invalid JWT_SECRET
          echo "Test 1: Invalid JWT_SECRET should cause immediate crash"
          
          set +e
          output=$(JWT_SECRET="invalid" bun run packages/config/src/index.ts 2>&1)
          exit_code=$?
          set -e
          
          if [ $exit_code -eq 0 ]; then
            echo "üö® VIOLATION DETECTED: S1 Protocol Failure!"
            echo ""
            echo "‚ùå App did NOT crash with invalid JWT_SECRET"
            echo "   Expected: Process exit with error"
            echo "   Got: Process continued running"
            echo ""
            echo "üîí Security Risk: App may run with insecure configuration"
            exit 1
          fi
          
          if echo "$output" | grep -q "S1 Violation"; then
            echo "‚úÖ Test 1 PASS: App crashed with S1 Violation message"
          else
            echo "‚ö†Ô∏è Test 1 PARTIAL: App crashed but without S1 Violation message"
          fi
          
          # Test 2: App must crash with missing required env vars
          echo ""
          echo "Test 2: Missing DATABASE_URL should cause crash"
          
          set +e
          output=$(JWT_SECRET="valid_secret_key_32_chars_longgg" DATABASE_URL="" bun run packages/config/src/index.ts 2>&1)
          exit_code=$?
          set -e
          
          if [ $exit_code -eq 0 ]; then
            echo "üö® VIOLATION DETECTED: S1 Protocol Failure!"
            echo ""
            echo "‚ùå App did NOT crash with missing DATABASE_URL"
            exit 1
          fi
          
          echo "‚úÖ Test 2 PASS: App crashed as expected"
          
          echo ""
          echo "‚úÖ S1 Fail-Fast Protocol verified - App crashes on invalid config"
        env:
          DATABASE_URL: postgresql://apex:apex@localhost:5432/test

      - name: Test S1 Success - Valid Configuration
        run: |
          echo "üß™ Testing S1 with valid configuration..."
          
          output=$(bun run packages/config/src/index.ts 2>&1)
          
          if echo "$output" | grep -q "S1 Compliance"; then
            echo "‚úÖ S1 Compliance verified with valid config"
          else
            echo "‚ö†Ô∏è S1 Compliance message not found in output"
          fi

  coverage-threshold-enforcement:
    name: üö® Violation Detection - Coverage Threshold (Rule 4.1)
    runs-on: ubuntu-latest
    needs: [coverage-gate]
    if: failure()
    steps:
      - name: Report Coverage Violation
        run: |
          echo "üö® CRITICAL VIOLATION DETECTED: Rule 4.1 (Test Coverage)"
          echo ""
          echo "‚ùå Coverage threshold NOT met!"
          echo ""
          echo "üìã Required Thresholds:"
          echo "   - Global Minimum: 80% (lines, functions, branches, statements)"
          echo "   - Critical Modules: 100%"
          echo "      * packages/provisioning/**"
          echo "      * packages/auth/**"
          echo "      * packages/middleware/**"
          echo ""
          echo "üìù Action Required:"
          echo "   1. Add tests for uncovered lines"
          echo "   2. Verify all new files have tests"
          echo "   3. Check coverage report in PR artifacts"
          echo ""
          echo "üõë Build rejected. Increase coverage before merging."
          exit 1

  zod-schema-lockdown:
    name: Zod Schema Lockdown (Rule 5.1)
    runs-on: ubuntu-latest
    needs: [security-audit-lint]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Verify Zod Usage (No Manual DTOs)
        run: |
          echo "üîç Checking for Zod Schema Compliance (Rule 5.1)..."
          
          # Check that API controllers use Zod validation (not manual validation)
          # Look for @UsePipes(ZodValidationPipe) or zod schemas
          
          # Check for manual validation patterns (forbidden)
          manual_validation=$(grep -r "if.*!.*body" apps/*/src --include="*.ts" | grep -v "test" || true)
          
          if [ -n "$manual_validation" ]; then
            echo "‚ö†Ô∏è WARNING: Possible manual validation found (should use Zod):"
            echo "$manual_validation"
            # Don't fail yet, just warn - some cases might be valid
          fi
          
          # Verify Zod schemas exist for DTOs
          zod_schemas=$(find packages -name "*.schema.ts" -o -name "*dto*.ts" | wc -l)
          
          if [ "$zod_schemas" -eq 0 ]; then
            echo "‚ùå FAIL: No Zod schemas found. All DTOs must use Zod (Rule 5.1)."
            exit 1
          fi
          
          echo "‚úÖ PASS: Zod schemas found ($zod_schemas files) - Rule 5.1 Compliant"

      - name: Verify No 'any' Types
        run: |
          echo "üîç Checking for 'any' type usage (Strict Mode)..."
          
          # Count 'any' types (allowing some in test files)
          any_count=$(grep -r ": any" packages/*/src --include="*.ts" | grep -v "\.test\.ts" | grep -v "// " | wc -l)
          
          if [ "$any_count" -gt 5 ]; then
            echo "‚ùå FAIL: Found $any_count 'any' types. Maximum allowed is 5 (Rule 5.1)."
            grep -r ": any" packages/*/src --include="*.ts" | grep -v "\.test\.ts" | grep -v "// "
            exit 1
          fi
          
          echo "‚úÖ PASS: 'any' type usage is acceptable ($any_count found)"

  db-schema-validation:
    name: Drizzle Schema Integrity Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - name: Install dependencies
        run: bun install
      - name: Validate Drizzle Schema (Drift Check)
        run: |
          cd packages/db
          # Ensure schema matches migrations (prevents accidental data loss)
          bunx drizzle-kit check:pg || (echo "‚ùå Schema drift detected! Run db:generate locally." && exit 1)

  build:
    name: Turborepo Build
    runs-on: ubuntu-latest
    needs: [s1-compliance, security-audit-lint, db-schema-validation, dependency-boundary-check, zod-schema-lockdown, uncovered-files-check, s1-fail-fast-test, biome-ignore-detection]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build all packages
        run: bun run turbo run build

      - name: Verify build outputs
        run: |
          test -d packages/config/dist || (echo "‚ùå config build missing" && exit 1)
          test -d packages/db/dist || (echo "‚ùå db build missing" && exit 1)
          test -d packages/auth/dist || (echo "‚ùå auth build missing" && exit 1)
          echo "‚úÖ All packages built successfully"

      - name: Generate Artifact Checksums
        run: |
          find packages/*/dist -type f -exec sha256sum {} \; > build_checksums.txt
          cat build_checksums.txt

  test-api-integration:
    name: API Integration Tests (Postgres/Redis/MinIO)
    runs-on: ubuntu-latest
    needs: [build]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: apex
          POSTGRES_PASSWORD: apex
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      minio:
        image: minio/minio
        env:
          MINIO_ROOT_USER: test
          MINIO_ROOT_PASSWORD: minioadmin123
        ports:
          - 9000:9000
          - 9001:9001
        options: >-
          --health-cmd "curl -f http://localhost:9000/minio/health/live"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          --entrypoint minio
          server /data --console-address ":9001"
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run Schema Migrations
        run: |
          cd packages/db
          bun run db:migrate
        env:
          DATABASE_URL: postgresql://apex:apex@localhost:5432/test

      - name: Run API Tests with Coverage
        run: |
          cd apps/api
          bun run test:cov
        env:
          DATABASE_URL: postgresql://apex:apex@localhost:5432/test
          JWT_SECRET: test_secret_key_for_ci_environment_only_32
          MINIO_ACCESS_KEY: test
          MINIO_SECRET_KEY: minioadmin123
          MINIO_ENDPOINT: localhost

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: api-coverage-report
          path: apps/api/coverage/

  coverage-gate:
    name: Coverage Gate (80% Overall, 90% Core)
    runs-on: ubuntu-latest
    needs: [test-api-integration]
    steps:
      - uses: actions/checkout@v4

      - name: Download coverage reports
        uses: actions/download-artifact@v4
        with:
          name: api-coverage-report
          path: coverage/

      - name: Verify Coverage Thresholds
        run: |
          echo "üîç Checking Coverage Thresholds..."
          
          # Check if coverage report exists
          if [ ! -f "coverage/coverage-summary.json" ]; then
            echo "‚ö†Ô∏è Coverage summary not found, checking lcov..."
            # Try to use lcov.info if available
            if [ ! -f "coverage/lcov.info" ]; then
              echo "‚ùå No coverage report found"
              exit 1
            fi
            echo "‚úÖ LCOV report found (manual verification needed)"
            exit 0
          fi
          
          # Parse coverage from summary
          overall_coverage=$(cat coverage/coverage-summary.json | grep -o '"lines":{[^}]*}' | grep -o '"pct":[0-9.]*' | head -1 | cut -d: -f2)
          
          echo "Overall Coverage: ${overall_coverage}%"
          
          # Check 80% overall threshold
          if (( $(echo "$overall_coverage < 80" | bc -l) )); then
            echo "‚ùå FAIL: Overall coverage ${overall_coverage}% is below 80% threshold (Rule 4.1)"
            exit 1
          fi
          
          echo "‚úÖ PASS: Overall coverage ${overall_coverage}% meets 80% threshold"

      - name: Verify No Zero-Coverage Files
        run: |
          echo "üîç Checking for Untested Files (Rule 4.1)..."
          
          if [ ! -f "coverage/coverage-final.json" ]; then
            echo "‚ö†Ô∏è Coverage final report not found, skipping zero-coverage check"
            exit 0
          fi
          
          # Extract files with 0% coverage
          zero_coverage=$(cat coverage/coverage-final.json | grep -E '".*":\s*\{[^}]*"pct":\s*0' | grep -o '"[^"]*\.ts":' | tr -d '":' || true)
          
          if [ -n "$zero_coverage" ]; then
            echo "‚ùå FAIL: The following files have ZERO coverage (Rule 4.1 Violation):"
            echo "$zero_coverage"
            echo ""
            echo "Every modified or new file must have tests. Untested code is broken code."
            exit 1
          fi
          
          echo "‚úÖ PASS: No zero-coverage files found"

      - name: Report Coverage to PR
        uses: davelosert/vitest-coverage-report-action@v2
        if: always() && github.event_name == 'pull_request'
        with:
          json-summary-path: './coverage/coverage-summary.json'
          json-final-path: './coverage/coverage-final.json'
          file-coverage-mode: all
          name: 'Apex v2 Coverage Report'

  uncovered-files-check:
    name: Uncovered Files Detection (Rule 4.1 Strict)
    runs-on: ubuntu-latest
    needs: [build]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: apex
          POSTGRES_PASSWORD: apex
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build packages
        run: bun run turbo run build

      - name: Run All Tests with Full Coverage
        run: |
          echo "üß™ Running full test suite with coverage..."
          bun x vitest run --coverage --reporter=json --reporter=verbose > coverage-report.txt 2>&1 || true
          cat coverage-report.txt
        env:
          DATABASE_URL: postgresql://apex:apex@localhost:5432/test
          JWT_SECRET: test_secret_key_for_ci_environment_only_32

      - name: Detect Uncovered New/Modified Files
        run: |
          echo "üîç Detecting uncovered files in PR..."
          
          # Get list of changed files in this PR
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            changed_files=$(git diff --name-only --diff-filter=AM origin/${{ github.base_ref }}...HEAD | grep -E '\.(ts|tsx)$' | grep -v '\.test\.' | grep -v '\.spec\.' || true)
          else
            # For push events, check all source files
            changed_files=$(find packages/*/src apps/*/src -name '*.ts' -not -name '*.test.ts' -not -name '*.spec.ts' 2>/dev/null || true)
          fi
          
          if [ -z "$changed_files" ]; then
            echo "‚úÖ No TypeScript files changed in this PR"
            exit 0
          fi
          
          echo "Changed files to check for coverage:"
          echo "$changed_files"
          
          # Check each changed file for coverage
          uncovered_files=""
          for file in $changed_files; do
            # Check if file exists in coverage report
            if ! grep -q "$file" coverage/coverage-final.json 2>/dev/null; then
              # File not in coverage report = not tested
              uncovered_files="$uncovered_files\n$file"
            fi
          done
          
          if [ -n "$uncovered_files" ]; then
            echo "‚ùå FAIL: The following modified/new files lack test coverage (Rule 4.1):"
            echo -e "$uncovered_files"
            echo ""
            echo "üìù Action Required:"
            echo "   1. Add unit tests for each uncovered file"
            echo "   2. Ensure coverage report includes these files"
            echo "   3. Coverage threshold: 100% for critical modules, 80% for others"
            exit 1
          fi
          
          echo "‚úÖ PASS: All modified/new files have test coverage"

  provisioning-smoke-test:
    name: Provisioning Smoke Test (North Star <60s)
    runs-on: ubuntu-latest
    needs: [build]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: apex
          POSTGRES_PASSWORD: apex
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      minio:
        image: minio/minio
        env:
          MINIO_ROOT_USER: test
          MINIO_ROOT_PASSWORD: minioadmin123
        ports:
          - 9000:9000
          - 9001:9001
        options: >-
          --health-cmd "curl -f http://localhost:9000/minio/health/live"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          --entrypoint minio
          server /data --console-address ":9001"
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build packages
        run: bun run turbo run build

      - name: Run Provisioning Smoke Test
        run: |
          echo "üöÄ Starting Provisioning Smoke Test (North Star: <60s)..."
          
          # Start timing
          start_time=$(date +%s)
          
          # Run provisioning for test tenant
          if bun run packages/provisioning/src/cli.ts --name="smoke-test-$(date +%s)" 2>&1; then
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            
            echo "‚úÖ Provisioning completed in ${duration} seconds"
            
            # Verify schema was created
            if psql "$DATABASE_URL" -c "\dn" | grep -q "tenant_smoke"; then
              echo "‚úÖ Schema verified in database"
            else
              echo "‚ùå Schema not found in database"
              exit 1
            fi
            
            # Check 60 second threshold (North Star)
            if [ "$duration" -gt 60 ]; then
              echo "‚ö†Ô∏è WARNING: Provisioning took ${duration}s, exceeds 60s North Star target"
              # Don't fail, just warn - this is a smoke test
            else
              echo "‚úÖ PASS: Provisioning completed within 60s North Star target"
            fi
          else
            echo "‚ùå FAIL: Provisioning failed"
            exit 1
          fi
        env:
          DATABASE_URL: postgresql://apex:apex@localhost:5432/test
          JWT_SECRET: test_secret_key_for_ci_environment_only_32
          MINIO_ACCESS_KEY: test
          MINIO_SECRET_KEY: minioadmin123
          MINIO_ENDPOINT: localhost

      - name: Cleanup Test Data
        if: always()
        run: |
          echo "üßπ Cleaning up smoke test data..."
          psql "$DATABASE_URL" -c "DROP SCHEMA IF EXISTS tenant_smoke_test CASCADE;" 2>/dev/null || true

  docker-health:
    name: Docker Stack E2E Ready Verification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: Start infrastructure (Wait for Health)
        run: |
          docker compose up -d --wait || {
            echo "‚ùå Docker compose failed to start"
            docker compose logs
            exit 1
          }

      - name: Verify Service Status
        run: |
          docker compose ps
          docker compose ps --all

          # Explicitly check each service
          docker compose exec -T postgres pg_isready -h localhost || exit 1
          docker compose exec -T redis redis-cli ping || exit 1

      - name: Cleanup
        if: always()
        run: docker compose down -v
