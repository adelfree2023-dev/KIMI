################################################################################
#  APEX PROJECT CODEBASE ARCHIVE
################################################################################
#
#  📊 STATISTICS SUMMARY:
#  ---------------------
#  📂 Total Files : 15
#  📝 Total Lines : 988
#  🔤 Total Words : 2,646
#  🧮 Total Chars : 29,469
#  🪙 Est. Tokens : 7,367 (Approx. for LLM Context)
#
################################################################################


/*******************************************************************************
 * FILE: biome.json
 * PATH: .\biome.json
 *******************************************************************************/
{
    "$schema": "https://biomejs.dev/schemas/1.5.0/schema.json",
    "organizeImports": {
        "enabled": true
    },
    "formatter": {
        "enabled": true,
        "formatWithErrors": false,
        "indentStyle": "space",
        "indentWidth": 2,
        "lineWidth": 80,
        "lineEnding": "lf"
    },
    "linter": {
        "enabled": true,
        "rules": {
            "recommended": true,
            "complexity": {
                "noBannedTypes": "error",
                "noExcessiveCognitiveComplexity": {
                    "level": "error",
                    "options": {
                        "maxAllowedComplexity": 10
                    }
                }
            },
            "correctness": {
                "noUnusedImports": "error",
                "noUnusedVariables": "error",
                "noUnusedFunctionParameters": "error",
                "noUnreachable": "error"
            },
            "security": {
                "noDangerouslySetInnerHtml": "error",
                "noGlobalEval": "error"
            },
            "style": {
                "noDefaultExport": "error",
                "useNamingConvention": {
                    "level": "error",
                    "options": {
                        "strictCase": true
                    }
                }
            },
            "suspicious": {
                "noConsoleLog": "warn",
                "noExplicitAny": "error",
                "noConsole": {
                    "level": "error",
                    "options": {
                        "allow": [
                            "error",
                            "warn"
                        ]
                    }
                }
            }
        }
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "single",
            "trailingComma": "es5",
            "semicolons": "always"
        }
    }
}

/*******************************************************************************
 * FILE: docker-compose.yml
 * PATH: .\docker-compose.yml
 *******************************************************************************/
version: "3.8"

services:
  # PostgreSQL with pgvector extension
  postgres:
    image: ankane/pgvector:latest
    container_name: apex-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-apex}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-apex_secret}
      POSTGRES_DB: ${POSTGRES_DB:-apex_v2}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U apex -d apex_v2"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - apex-network

  # Redis for Caching, Sessions, and Rate Limiting (S6)
  redis:
    image: redis:7-alpine
    container_name: apex-redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_secret}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - apex-network

  # MinIO (S3-Compatible Object Storage)
  minio:
    image: minio/minio:latest
    container_name: apex-minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin123}
      MINIO_BROWSER_REDIRECT_URL: http://localhost:9001
    volumes:
      - minio_data:/data
    ports:
      - "9000:9000"
      - "9001:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - apex-network

  # Create MinIO bucket on startup
  minio-init:
    image: minio/mc:latest
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      /usr/bin/mc config host add myminio http://minio:9000 ${MINIO_ROOT_USER:-minioadmin} ${MINIO_ROOT_PASSWORD:-minioadmin123};
      /usr/bin/mc mb myminio/apex-assets || true;
      /usr/bin/mc anonymous set download myminio/apex-assets;
      exit 0;
      "
    networks:
      - apex-network

  # Traefik Reverse Proxy
  traefik:
    image: traefik:v3.0
    container_name: apex-traefik
    restart: unless-stopped
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=admin@apex.com"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--ping=true"
      - "--log.level=INFO"
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080" # Traefik Dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_certs:/letsencrypt
    healthcheck:
      test: ["CMD", "traefik", "healthcheck"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - apex-network

  # Mailpit (Email Testing)
  mailpit:
    image: axllent/mailpit:latest
    container_name: apex-mailpit
    restart: unless-stopped
    ports:
      - "1025:1025" # SMTP
      - "8025:8025" # Web UI
    volumes:
      - mailpit_data:/data
    environment:
      MP_MAX_MESSAGES: 5000
      MP_DATABASE: /data/mailpit.db
    networks:
      - apex-network

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  minio_data:
    driver: local
  traefik_certs:
    driver: local
  mailpit_data:
    driver: local

networks:
  apex-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16


/*******************************************************************************
 * FILE: package.json
 * PATH: .\package.json
 *******************************************************************************/
{
    "name": "apex-v2",
    "private": true,
    "workspaces": [
        "apps/*",
        "packages/*"
    ],
    "scripts": {
        "build": "turbo run build",
        "dev": "turbo run dev",
        "lint": "turbo run lint",
        "test": "turbo run test",
        "test:unit": "turbo run test:unit",
        "format": "biome format --write .",
        "check": "biome check --apply .",
        "provision:tenant": "bun run --filter @apex/provisioning-cli"
    },
    "devDependencies": {
        "@biomejs/biome": "^1.5.0",
        "turbo": "^1.11.0"
    },
    "packageManager": "bun@1.0.0",
    "engines": {
        "bun": ">=1.0.0",
        "node": ">=20.0.0"
    }
}

/*******************************************************************************
 * FILE: turbo.json
 * PATH: .\turbo.json
 *******************************************************************************/
{
    "$schema": "https://turbo.build/schema.json",
    "globalDependencies": [
        "**/.env.*local"
    ],
    "pipeline": {
        "build": {
            "dependsOn": [
                "^build"
            ],
            "outputs": [
                ".next/**",
                "!.next/cache/**",
                "dist/**"
            ]
        },
        "lint": {
            "dependsOn": [
                "^build"
            ]
        },
        "test": {
            "dependsOn": [
                "^build"
            ]
        },
        "test:unit": {
            "dependsOn": [],
            "inputs": [
                "src/**/*.ts",
                "tests/**/*.ts"
            ]
        },
        "dev": {
            "cache": false,
            "persistent": true
        }
    }
}

/*******************************************************************************
 * FILE: package.json
 * PATH: .\packages\auth\package.json
 *******************************************************************************/
{
    "name": "@apex/auth",
    "version": "1.0.0",
    "type": "module",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
        }
    },
    "scripts": {
        "build": "bun build ./src/index.ts --outdir ./dist --target node",
        "test": "vitest run",
        "lint": "biome check ."
    },
    "dependencies": {
        "@nestjs/common": "^10.0.0",
        "@nestjs/jwt": "^10.2.0",
        "@nestjs/passport": "^10.0.0",
        "passport": "^0.7.0",
        "passport-jwt": "^4.0.0",
        "@apex/config": "workspace:*",
        "@apex/db": "workspace:*"
    },
    "devDependencies": {
        "@types/passport-jwt": "^3.0.0",
        "bun-types": "latest"
    }
}

/*******************************************************************************
 * FILE: index.ts
 * PATH: .\packages\auth\src\index.ts
 *******************************************************************************/
/**
 * Authentication & Authorization Module
 * S2: Tenant Isolation Enforcement via TenantScopedGuard
 */

import {
    Injectable,
    CanActivate,
    ExecutionContext,
    UnauthorizedException,
    ForbiddenException
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';

export interface AuthenticatedRequest extends Request {
    user: {
        userId: string;
        email: string;
        tenantId: string;
        role: string;
        impersonating?: boolean;
    };
    tenantId: string;
}

@Injectable()
export class TenantScopedGuard implements CanActivate {
    constructor(private jwtService: JwtService) { }

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const request = context.switchToHttp().getRequest<AuthenticatedRequest>();

        // 1. Extract JWT from cookie or header
        const token = this.extractToken(request);
        if (!token) {
            throw new UnauthorizedException('Authentication required');
        }

        // 2. Verify JWT
        try {
            const payload = await this.jwtService.verifyAsync(token);
            request.user = payload;
        } catch {
            throw new UnauthorizedException('Invalid token');
        }

        // 3. S2: Extract and validate tenant context
        const requestedTenantId = this.extractTenantId(request);

        if (!requestedTenantId) {
            throw new ForbiddenException('S2 Violation: Tenant context required');
        }

        // 4. S2: Strict Tenant Isolation Check
        // User can ONLY access their own tenant (unless impersonating as Super Admin)
        if (payload.tenantId !== requestedTenantId && !payload.impersonating) {
            // Log security event (S4 Audit)
            console.error(`🚨 S2 Violation: User ${payload.userId} from tenant ${payload.tenantId} attempted to access tenant ${requestedTenantId}`);

            throw new ForbiddenException(
                'S2 Isolation Violation: Cross-tenant access denied'
            );
        }

        // 5. Set tenant context for downstream use
        request.tenantId = requestedTenantId;

        return true;
    }

    private extractToken(request: Request): string | undefined {
        // Check Authorization header
        const authHeader = request.headers.authorization;
        if (authHeader?.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }

        // Check httpOnly cookie
        return request.cookies?.jwt;
    }

    private extractTenantId(request: Request): string | undefined {
        // Priority 1: X-Tenant-ID header
        const headerTenant = request.headers['x-tenant-id'];
        if (headerTenant) return headerTenant as string;

        // Priority 2: Subdomain (e.g., tenant1.apex.com)
        const host = request.headers.host || '';
        const subdomain = host.split('.')[0];
        if (subdomain && subdomain !== 'www' && subdomain !== 'apex') {
            return subdomain;
        }

        // Priority 3: Query param (for development)
        return request.query.tenantId as string;
    }
}

/**
 * Super Admin Guard (for God Mode)
 */
@Injectable()
export class SuperAdminGuard implements CanActivate {
    canActivate(context: ExecutionContext): boolean {
        const request = context.switchToHttp().getRequest<AuthenticatedRequest>();

        if (request.user.role !== 'SUPER_ADMIN') {
            throw new ForbiddenException('Super Admin access required');
        }

        return true;
    }
}

/**
 * JWT Strategy Configuration
 */
export const JwtStrategyConfig = {
    secret: process.env.JWT_SECRET,
    signOptions: {
        expiresIn: process.env.JWT_EXPIRES_IN || '7d',
    },
};


/*******************************************************************************
 * FILE: package.json
 * PATH: .\packages\config\package.json
 *******************************************************************************/
{
    "name": "@apex/config",
    "version": "1.0.0",
    "type": "module",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
        }
    },
    "scripts": {
        "build": "bun build ./src/index.ts --outdir ./dist --target node",
        "test": "vitest run",
        "test:unit": "vitest run --coverage",
        "lint": "biome check .",
        "clean": "rm -rf dist"
    },
    "dependencies": {
        "zod": "^3.22.4"
    },
    "devDependencies": {
        "@types/node": "^20.0.0",
        "bun-types": "latest",
        "vitest": "^1.0.0",
        "@biomejs/biome": "^1.5.0"
    }
}

/*******************************************************************************
 * FILE: index.test.ts
 * PATH: .\packages\config\src\index.test.ts
 *******************************************************************************/
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { validateEnv, EnvSchema, enforceS1Compliance } from './index';

describe('S1: Environment Verification Protocol', () => {
    const originalEnv = process.env;

    beforeEach(() => {
        process.env = { ...originalEnv };
        // Mock exit to prevent running tests from exiting
        vi.spyOn(process, 'exit').mockImplementation(() => {
            throw new Error('process.exit called');
        });
    });

    afterEach(() => {
        process.env = originalEnv;
        vi.restoreAllMocks();
    });

    describe('JWT_SECRET Validation', () => {
        it('should crash with S1 Violation when JWT_SECRET is missing', () => {
            delete process.env.JWT_SECRET;

            expect(() => validateEnv()).toThrow('S1 Violation');
            expect(() => validateEnv()).toThrow('Required');
        });

        it('should crash with S1 Violation when JWT_SECRET is too short (<32 chars)', () => {
            process.env.JWT_SECRET = 'short';

            expect(() => validateEnv()).toThrow('S1 Violation');
            expect(() => validateEnv()).toThrow('at least 32 characters');
        });

        it('should crash with S1 Violation when JWT_SECRET has invalid characters', () => {
            process.env.JWT_SECRET = 'invalid_secret_with_special@chars!';

            expect(() => validateEnv()).toThrow('S1 Violation');
            expect(() => validateEnv()).toThrow('invalid characters');
        });

        it('should pass with valid JWT_SECRET (32+ chars, alphanumeric)', () => {
            process.env.JWT_SECRET = 'valid_secret_key_32_chars_long_1234';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            process.env.MINIO_ACCESS_KEY = 'minioadmin';
            process.env.MINIO_SECRET_KEY = 'minioadmin123';

            expect(() => validateEnv()).not.toThrow();
        });
    });

    describe('Production Security Checks', () => {
        it('should crash in production with default JWT_SECRET', () => {
            process.env.NODE_ENV = 'production';
            process.env.JWT_SECRET = 'default_secret_key_32_chars_long_123';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            process.env.MINIO_ACCESS_KEY = 'minioadmin';
            process.env.MINIO_SECRET_KEY = 'minioadmin123';

            expect(() => validateEnv()).toThrow('S1 Violation');
            expect(() => validateEnv()).toThrow('default/test value');
        });

        it('should crash in production with localhost DB without SSL', () => {
            process.env.NODE_ENV = 'production';
            process.env.JWT_SECRET = 'valid_production_secret_32_chars_long';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            process.env.MINIO_ACCESS_KEY = 'minioadmin';
            process.env.MINIO_SECRET_KEY = 'minioadmin123';

            expect(() => validateEnv()).toThrow('S1 Violation');
            expect(() => validateEnv()).toThrow('SSL');
        });
    });

    describe('enforceS1Compliance', () => {
        it('should call process.exit(1) on validation failure', () => {
            delete process.env.JWT_SECRET;

            expect(() => enforceS1Compliance()).toThrow('process.exit called');
            expect(process.exit).toHaveBeenCalledWith(1);
        });
    });
});


/*******************************************************************************
 * FILE: index.ts
 * PATH: .\packages\config\src\index.ts
 *******************************************************************************/
/**
 * S1: Environment Verification Protocol
 * Constitution Reference: Article S1
 * Rule: Application MUST crash on invalid environment configuration
 */

import { z } from 'zod';

/**
 * Zod Schema for Environment Variables (Single Source of Truth)
 * Strict validation with no coercion
 */
export const EnvSchema = z.object({
    // Critical Security Variables
    JWT_SECRET: z
        .string()
        .min(32, 'S1 Violation: JWT_SECRET must be at least 32 characters')
        .regex(
            /^[A-Za-z0-9-_]+$/,
            'S1 Violation: JWT_SECRET contains invalid characters'
        ),

    JWT_EXPIRES_IN: z
        .string()
        .default('7d'),

    // Database Configuration
    DATABASE_URL: z
        .string()
        .url('S1 Violation: DATABASE_URL must be a valid URL')
        .startsWith('postgresql://', 'S1 Violation: Only PostgreSQL is supported'),

    // Redis Configuration
    REDIS_URL: z
        .string()
        .url('S1 Violation: REDIS_URL must be a valid URL')
        .default('redis://localhost:6379'),

    // MinIO/S3 Configuration
    MINIO_ENDPOINT: z.string().min(1),
    MINIO_PORT: z.string().default('9000'),
    MINIO_USE_SSL: z.enum(['true', 'false']).default('false'),
    MINIO_ACCESS_KEY: z.string().min(3),
    MINIO_SECRET_KEY: z.string().min(8),
    MINIO_BUCKET_NAME: z.string().default('apex-assets'),

    // Application Settings
    NODE_ENV: z
        .enum(['development', 'production', 'test'])
        .default('development'),

    PORT: z
        .string()
        .default('3000'),

    // Rate Limiting (S6)
    RATE_LIMIT_TTL: z.string().default('60'),
    RATE_LIMIT_MAX: z.string().default('100'),
});

export type EnvConfig = z.infer<typeof EnvSchema>;

/**
 * Validates environment variables at boot time
 * @throws Error with 'S1 Violation' prefix on validation failure
 * @returns Validated environment configuration
 */
export function validateEnv(): EnvConfig {
    try {
        const parsed = EnvSchema.parse(process.env);

        // Additional S1 Security Checks
        if (parsed.NODE_ENV === 'production') {
            if (parsed.JWT_SECRET.includes('default') || parsed.JWT_SECRET.includes('test')) {
                throw new Error('S1 Violation: JWT_SECRET appears to be a default/test value in production');
            }

            if (parsed.DATABASE_URL.includes('localhost') && !parsed.DATABASE_URL.includes('ssl')) {
                throw new Error('S1 Violation: Production database must use SSL');
            }
        }

        console.warn('✅ S1 Compliance: Environment variables validated successfully');
        return parsed;
    } catch (error) {
        if (error instanceof z.ZodError) {
            const issues = error.issues.map(i => `${i.path.join('.')}: ${i.message}`).join('; ');
            throw new Error(`S1 Violation: Environment validation failed - ${issues}`);
        }
        throw error;
    }
}

/**
 * Boot-time environment checker
 * Usage: Import this at the very top of your main.ts
 * Effect: Application will crash immediately if env is invalid
 */
export function enforceS1Compliance(): void {
    try {
        validateEnv();
    } catch (error) {
        console.error('❌ CRITICAL: S1 Protocol Violation');
        console.error(error instanceof Error ? error.message : 'Unknown error');
        console.error('Application startup aborted. Check your .env file.');
        process.exit(1);
    }
}

// Auto-execute on import for fail-fast behavior
if (process.env.ENABLE_S1_ENFORCEMENT !== 'false') {
    enforceS1Compliance();
}


/*******************************************************************************
 * FILE: drizzle.config.ts
 * PATH: .\packages\db\drizzle.config.ts
 *******************************************************************************/
import type { Config } from 'drizzle-kit';

export default {
    schema: './src/schema.ts',
    out: './drizzle',
    driver: 'pg',
    dbCredentials: {
        connectionString: process.env.DATABASE_URL || 'postgresql://apex:apex_secret@localhost:5432/apex_v2',
    },
} satisfies Config;


/*******************************************************************************
 * FILE: package.json
 * PATH: .\packages\db\package.json
 *******************************************************************************/
{
    "name": "@apex/db",
    "version": "1.0.0",
    "type": "module",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
        }
    },
    "scripts": {
        "build": "bun build ./src/index.ts --outdir ./dist --target node",
        "db:generate": "drizzle-kit generate:pg",
        "db:migrate": "bun run src/migrate.ts",
        "db:studio": "drizzle-kit studio",
        "test": "vitest run",
        "lint": "biome check ."
    },
    "dependencies": {
        "drizzle-orm": "^0.29.0",
        "pg": "^8.11.0",
        "@apex/config": "workspace:*"
    },
    "devDependencies": {
        "@types/pg": "^8.10.0",
        "drizzle-kit": "^0.20.0",
        "bun-types": "latest"
    }
}

/*******************************************************************************
 * FILE: index.ts
 * PATH: .\packages\db\src\index.ts
 *******************************************************************************/
/**
 * S2: Tenant Isolation Protocol
 * Schema-based isolation using Drizzle ORM
 */

import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import { validateEnv } from '@apex/config';

const env = validateEnv();

// Connection pool for public schema (tenant management)
export const publicPool = new Pool({
    connectionString: env.DATABASE_URL,
    ssl: env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

// Drizzle instance for public schema
export const publicDb = drizzle(publicPool);

/**
 * Get tenant-specific database connection
 * Sets search_path to isolate tenant data
 */
export function getTenantDb(tenantId: string) {
    const tenantSchema = `tenant_${tenantId}`;

    const pool = new Pool({
        connectionString: env.DATABASE_URL,
        ssl: env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    });

    // Set search path for this connection
    pool.on('connect', (client) => {
        client.query(`SET search_path TO ${tenantSchema}, public`);
    });

    return drizzle(pool);
}

/**
 * Create tenant schema (used in provisioning)
 */
export async function createTenantSchema(tenantId: string): Promise<void> {
    const schemaName = `tenant_${tenantId}`;

    await publicPool.query(`
    CREATE SCHEMA IF NOT EXISTS "${schemaName}";
    GRANT ALL ON SCHEMA "${schemaName}" TO CURRENT_USER;
  `);
}

/**
 * Drop tenant schema (used in deletion/kill switch)
 */
export async function dropTenantSchema(tenantId: string): Promise<void> {
    const schemaName = `tenant_${tenantId}`;
    await publicPool.query(`DROP SCHEMA IF EXISTS "${schemaName}" CASCADE`);
}


/*******************************************************************************
 * FILE: deploy.sh
 * PATH: .\scripts\deploy.sh
 *******************************************************************************/
#!/bin/bash
# Apex v2 - Deployment Script
# Usage: ./scripts/deploy.sh

# Configuration
SERVER_IP="136.111.146.88"
SSH_USER="apex-v2-dev"
SSH_KEY="C:/Users/Dell/.ssh/id_ed25519_apex"
TARGET_DIR="/opt/apex-v2"

echo "🚀 Deploying Apex v2 to $SSH_USER@$SERVER_IP..."

# 1. Create remote directory
echo "📂 Creating directory..."
ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no $SSH_USER@$SERVER_IP "sudo mkdir -p $TARGET_DIR && sudo chown $SSH_USER:$SSH_USER $TARGET_DIR"

# 2. Upload Files
echo "📦 Uploading project files..."
scp -i "$SSH_KEY" -o StrictHostKeyChecking=no -r \
  package.json \
  turbo.json \
  biome.json \
  docker-compose.yml \
  .env.example \
  apps \
  packages \
  docker \
  scripts \
  $SSH_USER@$SERVER_IP:$TARGET_DIR

# 3. Rename .env.example to .env (if not exists)
echo "🔧 Configuring environment..."
ssh -i "$SSH_KEY" $SSH_USER@$SERVER_IP "cp -n $TARGET_DIR/.env.example $TARGET_DIR/.env || true"

# 4. Execute Setup
echo "⚙️ Running server setup..."
ssh -i "$SSH_KEY" $SSH_USER@$SERVER_IP "chmod +x $TARGET_DIR/scripts/server-setup.sh && sudo $TARGET_DIR/scripts/server-setup.sh"

# 5. Start Infrastructure
echo "🐳 Starting Docker containers..."
ssh -i "$SSH_KEY" $SSH_USER@$SERVER_IP "cd $TARGET_DIR && sudo docker compose up -d"

echo "✅ Deployment Complete!"
echo "🌍 Server IP: http://$SERVER_IP"


/*******************************************************************************
 * FILE: server-setup.sh
 * PATH: .\scripts\server-setup.sh
 *******************************************************************************/
#!/bin/bash
# Apex v2 - Server Provisioning Script
# Compatible with Ubuntu 22.04 LTS
# Run as root (sudo su)

set -e

echo "🚀 Starting Apex v2 Server Provisioning..."

# 1. Update System
echo "📦 Updating system packages..."
apt-get update && apt-get upgrade -y
apt-get install -y curl unzip git jq tree

# 2. Install Docker & Docker Compose
echo "🐳 Installing Docker..."
if ! command -v docker &> /dev/null; then
    curl -fsSL https://get.docker.com -o get-docker.sh
    sh get-docker.sh
    rm get-docker.sh
    echo "✅ Docker installed"
else
    echo "✅ Docker already installed"
fi

# 3. Install Bun
echo "🥯 Installing Bun..."
if ! command -v bun &> /dev/null; then
    curl -fsSL https://bun.sh/install | bash
    # Add to path for this session
    export BUN_INSTALL="$HOME/.bun"
    export PATH="$BUN_INSTALL/bin:$PATH"
    echo "✅ Bun installed"
else
    echo "✅ Bun already installed"
fi

# 4. Prepare Directories
echo "ZE Creating project directories..."
mkdir -p /opt/apex-v2
chown -R $USER:$USER /opt/apex-v2

# 5. Firewall Setup (UFW)
echo "🛡️ Configuring Firewall..."
ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw allow 8080/tcp # Traefik Dashboard (secured)
ufw --force enable

echo "✅ Server Provisioning Complete!"
echo "➡️  Next Step: Run 'deploy.sh' from your local machine."


/*******************************************************************************
 * FILE: test-s1.ts
 * PATH: .\scripts\test-s1.ts
 *******************************************************************************/
#!/usr/bin/env bun
/**
 * S1 Protocol Demonstration Script
 * 
 * Usage: 
 *   bun run scripts/test-s1.ts
 * 
 * This script proves that the application crashes immediately
 * when environment variables are invalid (S1 Compliance)
 */

import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __dirname = dirname(fileURLToPath(import.meta.url));

console.log('🧪 S1 Protocol Test Suite');
console.log('='.repeat(50));

const tests = [
    {
        name: 'Missing JWT_SECRET',
        env: {
            JWT_SECRET: '',
            DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
            MINIO_ACCESS_KEY: 'test',
            MINIO_SECRET_KEY: 'minioadmin123'
        },
        shouldCrash: true,
        expectedError: 'S1 Violation'
    },
    {
        name: 'Short JWT_SECRET (<32 chars)',
        env: {
            JWT_SECRET: 'short_secret',
            DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
            MINIO_ACCESS_KEY: 'test',
            MINIO_SECRET_KEY: 'minioadmin123'
        },
        shouldCrash: true,
        expectedError: 'at least 32 characters'
    },
    {
        name: 'Invalid JWT_SECRET (special chars)',
        env: {
            JWT_SECRET: 'invalid_secret_with_@_symbol!',
            DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
            MINIO_ACCESS_KEY: 'test',
            MINIO_SECRET_KEY: 'minioadmin123'
        },
        shouldCrash: true,
        expectedError: 'invalid characters'
    },
    {
        name: 'Valid JWT_SECRET (32+ chars)',
        env: {
            JWT_SECRET: 'valid_secret_key_minimum_32_chars_long',
            DATABASE_URL: 'postgresql://test:test@localhost:5432/test',
            MINIO_ACCESS_KEY: 'test',
            MINIO_SECRET_KEY: 'minioadmin123'
        },
        shouldCrash: false,
        expectedError: null
    }
];

let passed = 0;
let failed = 0;

for (const test of tests) {
    console.log(`\n📝 Test: ${test.name}`);
    console.log(`   Expected: ${test.shouldCrash ? 'CRASH 💥' : 'SUCCESS ✅'}`);

    // Run test in subprocess
    const result = spawn('bun', ['run', 'packages/config/src/index.ts'], {
        env: { ...process.env, ...test.env, ENABLE_S1_ENFORCEMENT: 'true' },
        stdio: 'pipe',
        cwd: join(__dirname, '..')
    });

    let output = '';
    let errorOutput = '';

    result.stdout.on('data', (data) => {
        output += data.toString();
    });

    result.stderr.on('data', (data) => {
        errorOutput += data.toString();
    });

    const exitCode = await new Promise((resolve) => {
        result.on('close', resolve);
    });

    const crashed = exitCode !== 0;
    const fullOutput = output + errorOutput;

    if (crashed === test.shouldCrash) {
        if (test.shouldCrash && test.expectedError && fullOutput.includes(test.expectedError)) {
            console.log(`   Result: ✅ PASS (Crashed with expected error)`);
            console.log(`   Error: ${fullOutput.split('S1 Violation')[1]?.substring(0, 100) || 'N/A'}`);
            passed++;
        } else if (!test.shouldCrash) {
            console.log(`   Result: ✅ PASS (Started successfully)`);
            passed++;
        } else {
            console.log(`   Result: ❌ FAIL (Crashed but with wrong error)`);
            console.log(`   Output: ${fullOutput.substring(0, 200)}`);
            failed++;
        }
    } else {
        console.log(`   Result: ❌ FAIL (Expected ${test.shouldCrash ? 'crash' : 'success'}, got ${crashed ? 'crash' : 'success'})`);
        console.log(`   Output: ${fullOutput.substring(0, 200)}`);
        failed++;
    }
}

console.log('\n' + '='.repeat(50));
console.log(`📊 Results: ${passed} passed, ${failed} failed`);
console.log('='.repeat(50));

if (failed > 0) {
    process.exit(1);
}

